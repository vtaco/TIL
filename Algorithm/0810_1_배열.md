# 알고리즘

**문제를 해결하기 위한 절차나 방법**



좋은 알고리즘이란

1. 정확성 : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가



- 시간 복잡도

  실제 걸리는 시간(연산횟수)을 측정

  빅오 표기법 : 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시





배열 : 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조





## 정렬

**2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : dexcending) 재배열하는 것**

<br>

<br>

<br>

### 1. 버블 정렬(Bubble Sort)

**인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식**

O(n^^2)

```python
list = [30, 8, 95, 15, 21 ]

def BubbleSort(a) :
    for i in range(len(a)-1, 0, -1): #(1)
        for j in range(0, i):#(2)
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

(1) : 구간의 마지막을 정하는 역할

`Q1. 왜 끝의 인덱스 부터 앞으로 전진하는가? `

`A1. 버블 정렬을 하면 앞에서부터 비교해 나갑니다. 그렇게 가장 큰 값 (ex.95)를 만나게 된다면 리스트 내부의 어느 값보다도 크기 때문에 계속해서 뒤로 밀려나가게 됩니다. 즉, 최종적으로 가장 큰 값이 가장 뒤로 밀려나게 되면서 정렬될 자리에 위치하기 때문입니다.`

<br>

(2) : 줄어는 마지막 인덱스까지 비교하는 역할(실제로 비교가 일어나는 반복문)

`Q2. 위의 for문에서 마지막 값을 줄여나가는 데 굳이 또 마지막을 제한할 필요가 있을까?`

`A2. 값을 혼자 비교하지 않으니 j로 비교할 값을 선택하는 반복문 입니다. 즉, 위의 for문을 통해서 하나씩 값이 밀려 정렬이 될 때 그 뒤의 값은 다시 비교하지 않고 그 앞전의 값까지만 비교할 수 있는 코드입니다.`

<br><br>

<br>

### 2. 카운팅 정렬(Counting Sort)

**항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘**

O(n+k)

```python
def Counting_Sort(input_arr,sort_arr,count): #sort_arr은 외부에서 준비된 배열이라고 생각
    count_arr = [0] * (count + 1) #(1)
    
    for i in range(0,len(sort_arr)) : #(2)
        count_arr[input_arr[i]] += 1
        
	for i in range(1, len(count_arr)) : #(3)
        count_arr[i] += count[i-1]
        
	for i in range(len(sort_arr)-1, -1, -1): #(4)
        sort_arr[count_arr[input_arr[i]]-1] = input_arr[i]
        count_arr[input_arr[i]] -= 1

```

> ex)
>
> input_arr[0, 4, 1, 3, 1, 2, 4, 1]
>
> count_arr[0, 0, 0, 0, 0]

(1) : 카운트 정렬을 하기 위한 리스트 선언

`Q1. 카운트는 왜 주나요?`

`A1. 정수를 인덱스로 사용합니다. 그래서 충분한 카운트 배열의 공간을 할당하기 위해 입력 받은 배열의 가장 큰 정수 값을 전달 받습니다. 만약 가장 큰 수가 4라면 4초과하는 수는 없으며 4까지의 수만 카운트 하면 되기 때문입니다.(0~4)까지`

#### 즉, 카운트들을 위한 충분한 공간을 할당하기 위해 집합내 가장 큰 정수를 알아야함 그만한 배열을 선언해야 하니까!

### Data의 개수가 아닌 Data 원소의 범위

<br>

(2) : 입력 받은 배열의 숫자의 개수를 세기 위한 반복문

>i = 0
>
>count_arr[input[0]] ==> input[0]는 0을 리턴
>
>count_arr[0] += 1 ==> count[1, 0, 0, 0, 0]
>
><br>
>i = 1
>
>count_arr[input[1]] ==> input[1]은 4를 리턴
>
>count_arr[4] += 1 ==> count[1, 0, 0, 0, 1]
>
>''''''
>
>count_arr ==> [1, 3, 1, 1, 2] ===> index : 숫자개수 // 0 : 1개 // 1 : 3개 // 2 : 1개 // 3 : 1개 // 4 : 2개

`Q2-1. 왜 input_arr을 넣나요? 정렬하기 위한 값아닌가요?`

`A2. input_arr을 넣는 것이 카운팅 정렬의 핵심이자 제한사항입니다. 입력 받은 값을 인덱스의 역할로 바꾸어 1이라면 index가 1인 count_arr[1]를 증가 시킵니다. 이 반복문만 봐서는 이해하기 어려울 수 있으나 아래의 코드를 보면 왜 입력하는지 알 수 있을 것입니다.`

`Q2-2. 왜 카운팅 정렬의 제한사항이 되나요?`

`A2-2. 카운팅 정렬을 입력 값을 인덱스로 활용하는 것이 핵심입니다. 만약 소수나 정수가 아닌 다른 값이 입력이 된다면 인덱스로 사용할 수 없기 때문에 제한되는 사항입니다. 하지만 위의 버블 정렬보다 시간 복잡도 효율이 좋은 이점이 있습니다..`

#### 즉, 정수나 정수로 표현할 수 있는 자료에 대해서만 적용가능 합니다.

<br>

(3) : 각 인덱스 만큼 센 숫자들을 뒤쪽으로 더해 나가는 반복문

> count_arr[1, 4, 5, 6, 8]
>
> (4-2) 를 보고 왜 했느지 생각해보기

<br>

(4) : 카운팅 정렬의 핵심

```python
for i in range(len(sort_arr)-1, -1, -1): #(4-1)
        sort_arr[count_arr[input_arr[i]]-1] = input_arr[i] #(4-2)
        count_arr[input_arr[i]] -= 1 #(4-3)
```

(4-1) : 함수의 뒤쪽부터 값을 참조하게 됩니다.

> i in range(8 - 1, -1, -1) ==> range(7,6,5,4,3,2,1,0) // end는 값의 직전까지 돈다!

<br>

(4-2, 3) : 정렬!

> i = 7
>
> sort_arr[count_arr[input_arr[7]] - 1] ==> input_arr[7]은 1을 리턴
>
> sort_arr[count_arr[1]-1] ==> count_arr[1]은 4를 리턴 하고 -1이 빼짐
>
> sort_arr[3] = input_arr[7]
>
> sort_arr[0, 0, 0, 1, 0, 0, 0, 0]
>
> 맨 마지막에 있는 1이  4번째 자리로 이동
>
> count_arr[input_arr[i]] -= 1 ==>count_arr[1] 은 4이고 -1을 하게되서 3이된다!
>
> <br>
>
> 생각해보자!
>
> input_arr[7]에는 1이 저장되어 있다. 그리고 그 1의 개수는 count_arr[1] 4개로 저장되어있다
>
> 여기서 핵심은 input_arr에 저장되어 있는 값이 그대로 count_arr에 인덱스로 동일하게 사용한다는 것
>
> > 1이 나 4개 있어요에 (4 - 1)을 해서 3으로 배열에 인덱스로 활용하겠다는 것
> >
> > 그리고 sort_arr[0,0,0,1,0,0,0,0] 으로 index == 3에 저장이 된다.
>
> 그리고 -1을 해주어
>
> count_arr은 [1, 3, 5, 6, 8] 으로 된다

**한번 이해했다고 끝나는 정렬이 아니다 반복해서 확인하기**

<br>

<br>

<br>

### 3. 완전 검색(Exaustive Search)

**모든 경우의 수를 나열해보고 확인하는 기법**

경우의 수가 상대적으로 작을 때 유용하다.

수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.

```python
for i1 in range(1,4):
    for i2 in range(1,4):
        if i2 != i1 :
            for i3 in range(1,4):
                if i3 != i1 = and i3 != i2:
                    print(i1, i2, i3)
```

**각종 코테에서 완전 검색으로 접근하여 해답을 도출하고 성능 개선을 위해 다른 알고리즘을 사용하고 확인하는 것이 좋다**

<br>

<br>

<br>

### 4. 탐욕(Greedy) 알고리즘

**최적해를 구하는데 사용되는 근시안적 방법**

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방시으로 진행하여 최종적인 해답에 도달한다.

각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.



1. 해선택 : 현재 상테에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.

2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.

3. 해 검사 :  새로운 부분해 집합이 문제의 해가 되는지를 확인한다.

   아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다.



cf) 자리수 리스트에 넣기

```python
num = int(456789)
lst = []
for i in range(6):
    lst[num%10] += 1
    num //= 10
```

